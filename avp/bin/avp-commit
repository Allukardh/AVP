#!/opt/bin/python3
# =============================================================
# AutoVPN Platform (AVP)
# Component : AVP-COMMIT
# File      : avp-commit
# Role      : Git commit gate (V2-only: delegates governance to avp-meta; external changelog)
# Version   : v2.0.1 (2026-02-18)
# Status    : stable
# =============================================================

SCRIPT_VER="v2.0.1"

import argparse
import datetime as _dt
import os
import subprocess
import sys
from pathlib import Path
from typing import List, Optional, Tuple

RC_OK = 0
RC_FAIL = 1

SELF = Path(__file__).resolve()
AVP_ROOT = SELF.parents[1]      # .../avp
REPO_ROOT = SELF.parents[2]     # .../jffs/scripts
BIN_DIR = SELF.parent           # .../avp/bin
LOG_DIR = AVP_ROOT / "logs"
LOG_FILE = LOG_DIR / "avp_gitops.log"

GOV_RELS = (
    "services-start",
    "post-mount",
    "service-event",
)

def _ts() -> str:
    return _dt.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

def log(msg: str) -> None:
    line = f"{_ts()} [GITOPS] {msg}"
    print(line)
    try:
        LOG_DIR.mkdir(parents=True, exist_ok=True)
        with LOG_FILE.open("a", encoding="utf-8") as f:
            f.write(line + "\n")
    except Exception:
        pass

def err(msg: str) -> None:
    print(f"{_ts()} [GITOPS] ERR: {msg}", file=sys.stderr)

def find_bin(name: str, hints: List[str]) -> Optional[str]:
    for p in hints:
        if p and os.path.isfile(p) and os.access(p, os.X_OK):
            return p
    for d in os.environ.get("PATH", "").split(":"):
        d = d.strip()
        if not d:
            continue
        cand = os.path.join(d, name)
        if os.path.isfile(cand) and os.access(cand, os.X_OK):
            return cand
    return None

GIT_BIN = find_bin("git", ["/opt/bin/git", "/usr/bin/git", "/bin/git"])
META_BIN = str((BIN_DIR / "avp-meta").resolve())

def run(cmd: List[str], cwd: Optional[Path] = None, check: bool = True) -> Tuple[int, str]:
    p = subprocess.run(
        cmd,
        cwd=str(cwd) if cwd else None,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
    )
    out = p.stdout or ""
    if check and p.returncode != 0:
        err(f"cmd failed ({p.returncode}): {' '.join(cmd)}")
        if out.strip():
            print(out.rstrip())
        raise SystemExit(RC_FAIL)
    return p.returncode, out

def git_lines(args: List[str]) -> List[str]:
    _, out = run([GIT_BIN] + args, cwd=REPO_ROOT, check=True)
    return [ln.strip() for ln in out.splitlines() if ln.strip()]

def meta_check(relpath: str) -> None:
    if not os.path.isfile(META_BIN) or not os.access(META_BIN, os.X_OK):
        raise SystemExit("ERROR: avp-meta não encontrado/executável (obrigatório no V2).")
    run([META_BIN, "--check", "--targets", relpath], cwd=REPO_ROOT, check=True)

def governed_files(staged: List[str]) -> List[str]:
    out: List[str] = []
    for f in staged:
        if f.startswith("avp/bin/"):
            out.append(f)
            continue
        if f in GOV_RELS:
            out.append(f)
            continue
        if f.startswith("avp/www/") and f.endswith(".asp"):
            out.append(f)
            continue
    return out

def main(argv: List[str]) -> int:
    if not GIT_BIN:
        err("git não encontrado no PATH (instale via Entware ou ajuste PATH no bootstrap).")
        return RC_FAIL

    ap = argparse.ArgumentParser(prog="avp-commit", add_help=False)
    ap.add_argument("--help", action="store_true")
    ap.add_argument("--allow-multi", action="store_true", help="compat flag (no-op in python)")
    ap.add_argument("--add-all", action="store_true", help="run git add -A before commit")
    ap.add_argument("--no-push", action="store_true", help="do not push after commit (use only for offline/debug)")
    ap.add_argument("--allow-dirty", action="store_true", help="allow unstaged working tree changes")
    ap.add_argument("-m", "--message", type=str, default="")
    ns = ap.parse_args(argv)

    if ns.help or not ns.message:
        print(
            "Usage:\n"
            "  avp-commit -m \"<msg>\" [--add-all] [--no-push] [--allow-dirty]\n"
            "\n"
            "Notes (V2):\n"
            "- Governança (header/SCRIPT_VER/changelog externo) é SSOT via avp-meta --check.\n"
            "- Changelog é externo em ./avp/changelog/*.md (este script não lê changelog interno).\n"
            "- Prova final: git show --stat --name-status HEAD.\n"
        )
        return RC_OK if ns.help else RC_FAIL

    run([GIT_BIN, "rev-parse", "--is-inside-work-tree"], cwd=REPO_ROOT, check=True)

    if ns.add_all:
        run([GIT_BIN, "add", "-A"], cwd=REPO_ROOT, check=True)

    if not ns.allow_dirty:
        unstaged = git_lines(["diff", "--name-only"])
        if unstaged:
            err("working tree tem mudanças não staged. Use --allow-dirty ou faça git add -A.")
            for x in unstaged[:50]:
                print(x)
            return RC_FAIL

    run([GIT_BIN, "diff", "--check"], cwd=REPO_ROOT, check=True)
    run([GIT_BIN, "diff", "--cached", "--check"], cwd=REPO_ROOT, check=True)

    staged = git_lines(["diff", "--name-only", "--cached"])
    if not staged:
        err("nada staged para commitar.")
        return RC_FAIL

    gov = governed_files(staged)
    if gov:
        for f in gov:
            meta_check(f)
    else:
        log("WARN: nenhum arquivo governado detectado no staged (ok).")

    run([GIT_BIN, "commit", "-m", ns.message], cwd=REPO_ROOT, check=True)

    if not ns.no_push:
        run([GIT_BIN, "push", "origin", "main"], cwd=REPO_ROOT, check=True)

    run([GIT_BIN, "--no-pager", "show", "--stat", "--name-status", "HEAD"], cwd=REPO_ROOT, check=True)
    return RC_OK

if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
