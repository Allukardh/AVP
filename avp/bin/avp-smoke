#!/opt/bin/python3
# =============================================================
# AutoVPN Platform (AVP)
# Component : AVP-SMOKE
# File      : avp-smoke
# Role      : Smoke gate (V2-only: delegates metadata checks to avp-meta)
# Version   : v2.1.1 (2026-02-18)
# Status    : stable
# =============================================================

SCRIPT_VER="v2.1.1"

import argparse
import os
import sys
from pathlib import Path
from typing import List, Optional

import avp_common as C

RC_OK = 0
RC_FAIL = 1

REPO_ROOT, AVP_ROOT, BIN_DIR = C.self_paths(__file__)
META_BIN = (AVP_ROOT / "bin/avp-meta").resolve()

def _stdout(msg: str) -> None:
    print(msg)

def _log_plain(line: str) -> None:
    _stdout(f"{C.ts()} [SMOKE] {line}")

def _err_plain(line: str) -> None:
    print(f"{C.ts()} [SMOKE] ERR: {line}", file=sys.stderr)

def _log(line: str) -> None:
    if C.want_json():
        C.info("SMOKE", line)
    else:
        _log_plain(line)

def _err(line: str) -> None:
    if C.want_json():
        C.err("SMOKE", line)
    else:
        _err_plain(line)

def run(cmd: List[str], *, cwd: Optional[Path] = None) -> int:
    rc, out = C.run(cmd, cwd=cwd, check=False, capture=True)
    if out.strip():
        for ln in out.rstrip().splitlines():
            if C.want_json():
                C.info("SMOKE", ln)
            else:
                _stdout(ln)
    return RC_OK if rc == 0 else RC_FAIL

def is_shell_target(p: Path) -> bool:
    n = p.name
    if n in ("services-start", "post-mount", "service-event"):
        return True
    if n.endswith(".sh"):
        return True
    if n.startswith(("services-", "service-")):
        return True
    return False

def is_python_target(p: Path) -> bool:
    if p.parent.name == "bin" and p.parent.parent.name == "avp":
        return not p.name.endswith(".sh")
    return False

def should_skip_rel(rel: str) -> bool:
    rel = rel.strip().lstrip("/")
    # IMPORTANT: changelog externo é arquivo de apoio; não é “alvo governado” do smoke.
    if rel.startswith("avp/changelog/") and rel.endswith(".md"):
        return True
    return False

def meta_check_one(rel: str) -> int:
    if should_skip_rel(rel):
        return RC_OK
    if not META_BIN.exists() or not os.access(META_BIN, os.X_OK):
        _err("avp-meta não encontrado/executável (obrigatório no V2).")
        return RC_FAIL
    return run([str(META_BIN), "--check", "--targets", rel], cwd=REPO_ROOT)

def sh_syntax(rel: str) -> int:
    return run(["/bin/sh", "-n", str(REPO_ROOT / rel)], cwd=REPO_ROOT)

def py_compile(rel: str) -> int:
    return run(["/opt/bin/python3", "-m", "py_compile", str(REPO_ROOT / rel)], cwd=REPO_ROOT)

def git_diff_check() -> int:
    rc = RC_OK
    rc = max(rc, run(["git", "diff", "--check"], cwd=REPO_ROOT))
    rc = max(rc, run(["git", "diff", "--cached", "--check"], cwd=REPO_ROOT))
    return rc

def auto_targets_post() -> List[str]:
    changed = C.find_changed_files(REPO_ROOT)
    if not changed:
        return []
    out: List[str] = []
    for rel in changed:
        rel = rel.strip().lstrip("/")
        if not rel or should_skip_rel(rel):
            continue
        p = (REPO_ROOT / rel)
        if p.exists():
            out.append(rel)
    return sorted(set(out))

def main(argv: List[str]) -> int:
    ap = argparse.ArgumentParser(prog="avp-smoke", add_help=False)
    ap.add_argument("--help", action="store_true")
    ap.add_argument("--pre", action="store_true")
    ap.add_argument("--post", action="store_true")
    ap.add_argument("targets", nargs="*", default=[])
    ns = ap.parse_args(argv)

    if ns.help or (not ns.pre and not ns.post):
        _stdout(
            "Usage:\n"
            "  avp-smoke --pre  [targets...]\n"
            "  avp-smoke --post [targets...]\n\n"
            "Notas:\n"
            "- --pre sem targets = só git diff --check (worktree + staged).\n"
            "- --post sem targets = auto-detect via git (staged -> unstaged), exclui avp/changelog/*.md.\n"
            "- AVP_JSON=1 faz saída JSON mínima (logs em stderr).\n"
        )
        return RC_OK

    mode = "--pre" if ns.pre else "--post"
    if not C.want_json():
        _log_plain(f"AVP-SMOKE {SCRIPT_VER} MODE={mode}")

    rc = RC_OK
    rc = max(rc, git_diff_check())

    # targets explícitos sempre ganham.
    targets: List[str] = list(ns.targets or [])

    # auto-target SOMENTE no --post
    if not targets and ns.post:
        targets = auto_targets_post()

    checked: List[str] = []
    for t in targets:
        rel = t.strip().lstrip("/")
        if not rel or should_skip_rel(rel):
            continue
        p = (REPO_ROOT / rel)
        if not p.exists():
            _err(f"alvo não existe: {rel}")
            rc = RC_FAIL
            continue

        checked.append(rel)

        rc = max(rc, meta_check_one(rel))

        if is_shell_target(p):
            rc = max(rc, sh_syntax(rel))
        if is_python_target(p):
            rc = max(rc, py_compile(rel))

    if C.want_json():
        C.jprint({
            "component": "AVP-SMOKE",
            "version": SCRIPT_VER,
            "mode": mode,
            "rc": 0 if rc == RC_OK else 1,
            "targets": checked,
        })
        return rc

    if rc == RC_OK:
        _log_plain("OK")
    else:
        _err_plain("FAIL")
    return rc

if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
