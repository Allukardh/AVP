#!/opt/bin/python3
from __future__ import annotations

# =============================================================
# AutoVPN Platform (AVP)
# Component : AVP-SMOKE
# File      : avp-smoke
# Role      : Smoke gate (V2-only: no internal changelog; delegates metadata checks to avp-meta)
# Version   : v2.0.0 (2026-02-17)
# Status    : stable
# =============================================================

SCRIPT_VER="v2.0.0"

import argparse
import datetime as _dt
import os
import subprocess
import sys
from pathlib import Path
from typing import List

RC_OK = 0
RC_FAIL = 1

REPO_ROOT = Path("/jffs/scripts")
META_BIN = Path("/jffs/scripts/avp/bin/avp-meta")

def ts() -> str:
    return _dt.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

def info(msg: str) -> None:
    print(f"{ts()} [SMOKE] {msg}")

def err(msg: str) -> None:
    print(f"{ts()} [SMOKE] ERR: {msg}", file=sys.stderr)

def run(cmd: List[str], check: bool = False) -> int:
    try:
        r = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        if r.stdout:
            for ln in r.stdout.rstrip().splitlines():
                print(ln)
        if check and r.returncode != 0:
            return RC_FAIL
        return RC_OK if r.returncode == 0 else RC_FAIL
    except FileNotFoundError:
        err(f"cmd não encontrado: {cmd[0]}")
        return RC_FAIL

def is_shell_target(p: Path) -> bool:
    name = p.name
    if name in ("services-start", "post-mount", "service-event"):
        return True
    if name.endswith(".sh"):
        return True
    # hooks do Merlin sem extensão geralmente são shell
    if name.startswith(("services-", "service-")):
        return True
    return False

def is_python_target(p: Path) -> bool:
    # AVP V2: avp/bin/* sem extensão tende a ser python
    if p.parent.name == "bin" and p.parent.parent.name == "avp":
        # exceto wrappers .sh (que vamos eliminar na migração)
        return not p.name.endswith(".sh")
    return False

def meta_check_one(rel: str) -> int:
    if not META_BIN.exists() or not os.access(META_BIN, os.X_OK):
        err("avp-meta não encontrado/executável (obrigatório no V2).")
        return RC_FAIL
    return run([str(META_BIN), "--check", "--targets", rel], check=True)

def sh_syntax(rel: str) -> int:
    # BusyBox sh -n
    return run(["/bin/sh", "-n", str(REPO_ROOT / rel)], check=True)

def py_compile(rel: str) -> int:
    return run(["/opt/bin/python3", "-m", "py_compile", str(REPO_ROOT / rel)], check=True)

def git_diff_check() -> int:
    # checks rápidos (sem “prova gigante”)
    rc = RC_OK
    rc = max(rc, run(["git", "diff", "--check"]))
    rc = max(rc, run(["git", "diff", "--cached", "--check"]))
    return rc

def main(argv: List[str]) -> int:
    ap = argparse.ArgumentParser(prog="avp-smoke", add_help=False)
    ap.add_argument("--help", action="store_true")
    ap.add_argument("--pre", action="store_true")
    ap.add_argument("--post", action="store_true")
    ap.add_argument("targets", nargs="*", default=[])
    ns = ap.parse_args(argv)

    if ns.help or (not ns.pre and not ns.post):
        print(
            "Usage:\n"
            "  avp-smoke --pre  [targets...]\n"
            "  avp-smoke --post [targets...]\n\n"
            "Notas:\n"
            "- V2-only: sem changelog interno; governança via avp-meta + changelog externo.\n"
            "- Faz git diff --check (worktree + staged), sh -n (alvos shell) e py_compile (alvos python).\n"
        )
        return RC_OK

    mode = "--pre" if ns.pre else "--post"
    info(f"AVP-SMOKE {SCRIPT_VER} MODE={mode}")

    rc = RC_OK
    rc = max(rc, git_diff_check())

    # se não passar targets, smoke “global” (só diff-check)
    for t in ns.targets:
        rel = t.lstrip("/")
        p = (REPO_ROOT / rel)
        if not p.exists():
            err(f"alvo não existe: {rel}")
            rc = RC_FAIL
            continue

        # 1) governança V2 via meta (header/SCRIPT_VER/changelog externo)
        rc = max(rc, meta_check_one(rel))

        # 2) sintaxe por tipo
        if is_shell_target(p):
            rc = max(rc, sh_syntax(rel))
        if is_python_target(p):
            rc = max(rc, py_compile(rel))

    if rc == RC_OK:
        info("OK")
    else:
        err("FAIL")
    return rc

if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
