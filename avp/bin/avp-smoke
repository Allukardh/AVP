#!/opt/bin/python3
from __future__ import annotations

# =============================================================
# AutoVPN Platform (AVP)
# Component : AVP-SMOKE
# File      : avp-smoke
# Role      : Smoke gate (V2-only: delegates metadata checks to avp-meta)
# Version   : v2.1.1 (2026-02-18)
# Status    : stable
# =============================================================

SCRIPT_VER="v2.1.1"

import argparse
import datetime as _dt
import os
import subprocess
import sys
from pathlib import Path
from typing import List, Optional, Tuple

# local shared helpers (kept minimal; no dependency on imports)
def ts() -> str:
    return _dt.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

def want_json() -> bool:
    v = (os.environ.get("AVP_JSON") or "").strip().lower()
    return v in ("1","true","yes","on")

def info(msg: str) -> None:
    (sys.stderr if want_json() else sys.stdout).write(f"{ts()} [SMOKE] {msg}\n")

def err(msg: str) -> None:
    sys.stderr.write(f"{ts()} [SMOKE] ERR: {msg}\n")

RC_OK = 0
RC_FAIL = 1

SELF = Path(__file__).resolve()
AVP_ROOT = SELF.parents[1]      # .../avp
REPO_ROOT = SELF.parents[2]     # .../jffs/scripts
META_BIN = (AVP_ROOT / "bin/avp-meta").resolve()

CORE_AUTO = [
    "avp/bin/avp",
    "avp/bin/avp-meta",
    "avp/bin/avp-smoke",
    "avp/bin/avp-apply",
    "avp/bin/avp-commit",
    "avp/bin/avp-tag",
    "avp/lib/avp_common.py",
]

def run(cmd: List[str], *, cwd: Optional[Path] = None, check: bool = False) -> Tuple[int,str]:
    try:
        r = subprocess.run(
            cmd,
            cwd=str(cwd) if cwd else None,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
        )
        out = (r.stdout or "")
        if out and not want_json():
            for ln in out.rstrip().splitlines():
                print(ln)
        elif out and want_json():
            # não poluir stdout quando em modo JSON
            sys.stderr.write(out if out.endswith("\n") else out + "\n")
        if check and r.returncode != 0:
            return RC_FAIL, out
        return (RC_OK if r.returncode == 0 else RC_FAIL), out
    except FileNotFoundError:
        return RC_FAIL, f"cmd não encontrado: {cmd[0]}"

def is_shell_target(p: Path) -> bool:
    name = p.name
    if name in ("services-start", "post-mount", "service-event"):
        return True
    if name.endswith(".sh"):
        return True
    if name.startswith(("services-", "service-")):
        return True
    return False

def is_python_target(p: Path) -> bool:
    # avp/bin executáveis python (sem .sh) e avp/lib/*.py
    if p.parent.name == "bin" and p.parent.parent.name == "avp":
        return not p.name.endswith(".sh")
    if p.parent.name == "lib" and p.parent.parent.name == "avp" and p.name.endswith(".py"):
        return True
    return False

def meta_check_one(rel: str) -> int:
    if not META_BIN.exists() or not os.access(META_BIN, os.X_OK):
        err("avp-meta não encontrado/executável (obrigatório no V2).")
        return RC_FAIL
    rc, _ = run([str(META_BIN), "--check", "--targets", rel], cwd=REPO_ROOT, check=True)
    return rc

def sh_syntax(rel: str) -> int:
    rc, _ = run(["/bin/sh", "-n", str(REPO_ROOT / rel)], cwd=REPO_ROOT, check=True)
    return rc

def py_compile(rel: str) -> int:
    rc, _ = run(["/opt/bin/python3", "-m", "py_compile", str(REPO_ROOT / rel)], cwd=REPO_ROOT, check=True)
    return rc

def git_diff_check() -> int:
    rc1, _ = run(["git", "diff", "--check"], cwd=REPO_ROOT)
    rc2, _ = run(["git", "diff", "--cached", "--check"], cwd=REPO_ROOT)
    return max(rc1, rc2)

def main(argv: List[str]) -> int:
    ap = argparse.ArgumentParser(prog="avp-smoke", add_help=False)
    ap.add_argument("--help", action="store_true")
    ap.add_argument("--pre", action="store_true")
    ap.add_argument("--post", action="store_true")
    ap.add_argument("targets", nargs="*", default=[])
    ns = ap.parse_args(argv)

    if ns.help or (not ns.pre and not ns.post):
        print(
            "Usage:\n"
            "  avp-smoke --pre  [targets...]\n"
            "  avp-smoke --post [targets...]\n\n"
            "Notas:\n"
            "- V2-only: governança via avp-meta.\n"
            "- Faz git diff --check (worktree + staged), sh -n (shell) e py_compile (python).\n"
            "- Sem fiscalização de changelog/docs em .md.\n"
        )
        return RC_OK

    mode = "--pre" if ns.pre else "--post"
    info(f"AVP-SMOKE {SCRIPT_VER} MODE={mode}")

    rc = RC_OK
    rc = max(rc, git_diff_check())

    targets = ns.targets[:] if ns.targets else CORE_AUTO
    checked: List[str] = []
    for t in targets:
        rel = t.lstrip("/")
        p = (REPO_ROOT / rel)
        if not p.exists():
            err(f"alvo não existe: {rel}")
            rc = RC_FAIL
            continue

        checked.append(rel)
        rc = max(rc, meta_check_one(rel))

        if is_shell_target(p):
            rc = max(rc, sh_syntax(rel))
        if is_python_target(p):
            rc = max(rc, py_compile(rel))

    if want_json():
        # stdout limpo: só JSON
        out = {
            "component":"AVP-SMOKE",
            "version":SCRIPT_VER,
            "mode":mode,
            "rc":rc,
            "targets":checked,
        }
        import json
        print(json.dumps(out, ensure_ascii=False, separators=(",",":")))
        return rc

    if rc == RC_OK:
        info("OK")
    else:
        err("FAIL")
    return rc

if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
