#!/opt/bin/python3
# =============================================================
# AutoVPN Platform (AVP)
# Component : AVP-SMOKE
# File      : avp-smoke
# Role      : Smoke gate (V2-only: no internal changelog; delegates metadata checks to avp-meta)
# Version   : v2.0.1 (2026-02-18)
# Status    : stable
# =============================================================

SCRIPT_VER="v2.0.1"

import argparse
import datetime as _dt
import os
import subprocess
import sys
from pathlib import Path
from typing import List, Optional

RC_OK = 0
RC_FAIL = 1

SELF = Path(__file__).resolve()
AVP_ROOT = SELF.parents[1]
REPO_ROOT = SELF.parents[2]
META_BIN = (AVP_ROOT / "bin/avp-meta").resolve()

def ts() -> str:
    return _dt.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

def info(msg: str) -> None:
    print(f"{ts()} [SMOKE] {msg}")

def err(msg: str) -> None:
    print(f"{ts()} [SMOKE] ERR: {msg}", file=sys.stderr)

def run(cmd: List[str], *, cwd: Optional[Path] = None, check: bool = False) -> int:
    try:
        r = subprocess.run(
            cmd,
            cwd=str(cwd) if cwd else None,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
        )
        if r.stdout:
            for ln in r.stdout.rstrip().splitlines():
                print(ln)
        if check and r.returncode != 0:
            return RC_FAIL
        return RC_OK if r.returncode == 0 else RC_FAIL
    except FileNotFoundError:
        err(f"cmd não encontrado: {cmd[0]}")
        return RC_FAIL

def is_shell_target(p: Path) -> bool:
    name = p.name
    if name in ("services-start", "post-mount", "service-event"):
        return True
    if name.endswith(".sh"):
        return True
    if name.startswith(("services-", "service-")):
        return True
    return False

def is_python_target(p: Path) -> bool:
    if p.parent.name == "bin" and p.parent.parent.name == "avp":
        return not p.name.endswith(".sh")
    return False

def meta_check_one(rel: str) -> int:
    if not META_BIN.exists() or not os.access(META_BIN, os.X_OK):
        err("avp-meta não encontrado/executável (obrigatório no V2).")
        return RC_FAIL
    return run([str(META_BIN), "--check", "--targets", rel], cwd=REPO_ROOT, check=True)

def sh_syntax(rel: str) -> int:
    return run(["/bin/sh", "-n", str(REPO_ROOT / rel)], cwd=REPO_ROOT, check=True)

def py_compile(rel: str) -> int:
    return run(["/opt/bin/python3", "-m", "py_compile", str(REPO_ROOT / rel)], cwd=REPO_ROOT, check=True)

def git_diff_check() -> int:
    rc = RC_OK
    rc = max(rc, run(["git", "diff", "--check"], cwd=REPO_ROOT))
    rc = max(rc, run(["git", "diff", "--cached", "--check"], cwd=REPO_ROOT))
    return rc

def main(argv: List[str]) -> int:
    ap = argparse.ArgumentParser(prog="avp-smoke", add_help=False)
    ap.add_argument("--help", action="store_true")
    ap.add_argument("--pre", action="store_true")
    ap.add_argument("--post", action="store_true")
    ap.add_argument("targets", nargs="*", default=[])
    ns = ap.parse_args(argv)

    if ns.help or (not ns.pre and not ns.post):
        print(
            "Usage:\n"
            "  avp-smoke --pre  [targets...]\n"
            "  avp-smoke --post [targets...]\n\n"
            "Notas:\n"
            "- V2-only: sem changelog interno; governança via avp-meta + changelog externo.\n"
            "- Faz git diff --check (worktree + staged), sh -n (alvos shell) e py_compile (alvos python).\n"
        )
        return RC_OK

    mode = "--pre" if ns.pre else "--post"
    info(f"AVP-SMOKE {SCRIPT_VER} MODE={mode}")

    rc = RC_OK
    rc = max(rc, git_diff_check())

    for t in ns.targets:
        rel = t.lstrip("/")
        p = (REPO_ROOT / rel)
        if not p.exists():
            err(f"alvo não existe: {rel}")
            rc = RC_FAIL
            continue

        rc = max(rc, meta_check_one(rel))

        if is_shell_target(p):
            rc = max(rc, sh_syntax(rel))
        if is_python_target(p):
            rc = max(rc, py_compile(rel))

    if rc == RC_OK:
        info("OK")
    else:
        err("FAIL")
    return rc

if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
