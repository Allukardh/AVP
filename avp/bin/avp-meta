#!/opt/bin/python3
# =============================================================
# AutoVPN Platform (AVP)
# Component : AVP-META
# File      : avp-meta
# Role      : Metadata governor (V2-only: header + SCRIPT_VER + external changelog)
# Version   : v1.0.3 (2026-02-18)
# Status    : stable
# =============================================================

SCRIPT_VER="v1.0.3"

import argparse
import datetime as _dt
import json
import os
import re
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional, Tuple

RC_OK = 0
RC_FAIL = 1
RC_NEEDS_NORMALIZE = 2

SELF = Path(__file__).resolve()
AVP_ROOT = SELF.parents[1]   # .../avp
REPO_ROOT = SELF.parents[2]  # .../jffs/scripts
CHANGELOG_DIR = AVP_ROOT / "changelog"
LOG_DIR = AVP_ROOT / "logs"
LOG_FILE = LOG_DIR / "avp_meta.log"

_VERSION_RE = re.compile(r"^v\d+\.\d+\.\d+$")
_DATE_RE = re.compile(r"^\d{4}-\d{2}-\d{2}$")

HDR_KV_RE = {
    "component": re.compile(r"^\s*#\s*Component\s*:\s*(.+?)\s*$", re.M),
    "file": re.compile(r"^\s*#\s*File\s*:\s*(.+?)\s*$", re.M),
    "role": re.compile(r"^\s*#\s*Role\s*:\s*(.+?)\s*$", re.M),
    "status": re.compile(r"^\s*#\s*Status\s*:\s*(.+?)\s*$", re.M),
    "version": re.compile(r"^\s*#\s*Version\s*:\s*(v\d+\.\d+\.\d+)\s*\((\d{4}-\d{2}-\d{2})\)\s*$", re.M),
}

SCRIPT_VER_RE = re.compile(r'^\s*SCRIPT_VER\s*=\s*"?\s*(v\d+\.\d+\.\d+)\s*"?\s*$', re.M)

def _ts() -> str:
    return _dt.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

def log(msg: str) -> None:
    line = f"{_ts()} [META] {msg}"
    print(line)
    try:
        LOG_DIR.mkdir(parents=True, exist_ok=True)
        with LOG_FILE.open("a", encoding="utf-8") as f:
            f.write(line + "\n")
    except Exception:
        pass

def err(msg: str) -> None:
    print(f"{_ts()} [META] ERR: {msg}", file=sys.stderr)

def die(msg: str, rc: int = RC_FAIL) -> int:
    err(msg)
    return rc

def validate_version(v: str) -> None:
    if not _VERSION_RE.match(v):
        raise ValueError(f"version inválida: {v} (esperado vX.Y.Z)")

def validate_date(d: str) -> None:
    if not _DATE_RE.match(d):
        raise ValueError(f"date inválida: {d} (esperado YYYY-MM-DD)")

def is_changelog_md(path: Path) -> bool:
    try:
        rp = path.resolve()
    except Exception:
        rp = path
    return (CHANGELOG_DIR in rp.parents) and rp.suffix.lower() == ".md"

def detect_lang(text: str, path: Path) -> str:
    if text.startswith("#!") and "python" in text.splitlines()[0]:
        return "python"
    if text.startswith("#!"):
        return "shell"
    if path.parent.name == "bin" and path.parent.parent.name == "avp":
        return "python"
    return "shell"

@dataclass
class HeaderInfo:
    component: str
    file: str
    role: str
    status: str
    version: str
    date: str
    script_ver: str

def parse_header(text: str) -> Optional[HeaderInfo]:
    mver = HDR_KV_RE["version"].search(text)
    msv = SCRIPT_VER_RE.search(text)
    if not mver or not msv:
        return None

    def _get(key: str) -> str:
        m = HDR_KV_RE[key].search(text)
        return (m.group(1).strip() if m else "")

    component = _get("component")
    file_ = _get("file")
    role = _get("role")
    status = _get("status")
    version = mver.group(1).strip()
    date = mver.group(2).strip()
    script_ver = msv.group(1).strip()

    if not component or not file_ or not status:
        return None

    return HeaderInfo(component, file_, role or "n/a", status, version, date, script_ver)

def component_to_changelog(component: str) -> Path:
    c = component.strip().upper()
    slug = c[4:].lower() if c.startswith("AVP-") else c.lower()
    if slug in ("git", "gitops"):
        slug = "gitops"
    if slug in ("boot", "hook", "hooks"):
        slug = "hooks"
    return CHANGELOG_DIR / f"{slug}.md"

def ensure_changelog(component: str) -> Path:
    CHANGELOG_DIR.mkdir(parents=True, exist_ok=True)
    p = component_to_changelog(component)
    if not p.exists():
        p.write_text(f"# {component.strip().upper()}\n", encoding="utf-8")
    return p

def changelog_has_entry(component: str, version: str, date: Optional[str] = None) -> bool:
    p = component_to_changelog(component)
    if not p.exists():
        return False
    txt = p.read_text(encoding="utf-8", errors="replace")
    if date:
        return f"## {version} ({date})" in txt
    return re.search(rf"^##\s+{re.escape(version)}\s+\(\d{{4}}-\d{{2}}-\d{{2}}\)\s*$", txt, re.M) is not None

def upsert_changelog_entry(component: str, version: str, date: str, bullets: List[str]) -> None:
    validate_version(version)
    validate_date(date)

    p = ensure_changelog(component)
    txt = p.read_text(encoding="utf-8", errors="replace")
    lines = txt.splitlines()

    if not lines or not lines[0].startswith("# "):
        lines = [f"# {component.strip().upper()}", ""]

    header = f"## {version} ({date})"

    norm: List[str] = []
    for b in bullets:
        b = (b or "").strip()
        if not b:
            continue
        if b.startswith("- "):
            norm.append(b)
        elif b.startswith("* "):
            norm.append("- " + b[2:].strip())
        else:
            norm.append("- " + b)

    if not norm:
        return

    sec = None
    for i, ln in enumerate(lines):
        if ln.strip() == header:
            sec = i
            break

    if sec is None:
        insert_at = 1
        if len(lines) == 1:
            lines.append("")
        if lines[1].strip() != "":
            lines.insert(1, "")
        insert_at = 2
        block = [header] + norm + [""]
        lines[insert_at:insert_at] = block
    else:
        end = sec + 1
        while end < len(lines) and not lines[end].startswith("## "):
            end += 1
        existing = set(ln.strip() for ln in lines[sec+1:end] if ln.strip().startswith("- "))
        add = [b for b in norm if b.strip() not in existing]
        if add:
            lines[sec+1:sec+1] = add
        if end <= len(lines) and (end == len(lines) or lines[end-1].strip() != ""):
            lines.insert(end, "")

    p.write_text("\n".join(lines).rstrip() + "\n", encoding="utf-8")

def split_body(text: str, lang: str) -> Tuple[str, str]:
    lines = text.splitlines(keepends=True)
    if not lines:
        return ("", "")
    shebang = ""
    i = 0
    if lines[0].startswith("#!"):
        shebang = lines[0]
        i = 1

    sv_line = None
    for j in range(i, min(len(lines), i + 300)):
        if lines[j].lstrip().startswith("SCRIPT_VER"):
            sv_line = j
            break
    if sv_line is None:
        return (shebang, "".join(lines[i:]))

    if lang == "python":
        k = sv_line + 1
        while k < len(lines) and lines[k].strip() == "":
            k += 1
        return (shebang, "".join(lines[k:]))

    setu = None
    for j in range(sv_line + 1, min(len(lines), sv_line + 120)):
        if lines[j].strip() == "set -u":
            setu = j
            break
    if setu is None:
        return (shebang, "".join(lines[sv_line+1:]))

    m = setu + 1
    while m < len(lines) and lines[m].strip() == "":
        m += 1
    return (shebang, "".join(lines[m:]))

def build_header(lang: str, h: HeaderInfo) -> str:
    if lang == "python":
        return (
            "# =============================================================\n"
            "# AutoVPN Platform (AVP)\n"
            f"# Component : {h.component}\n"
            f"# File      : {h.file}\n"
            f"# Role      : {h.role}\n"
            f"# Version   : {h.version} ({h.date})\n"
            f"# Status    : {h.status}\n"
            "# =============================================================\n"
            "\n"
            f'SCRIPT_VER="{h.version}"\n'
            "\n"
        )

    return (
        "# =============================================================\n"
        "# AutoVPN Platform (AVP)\n"
        f"# Component : {h.component}\n"
        f"# File      : {h.file}\n"
        f"# Role      : {h.role}\n"
        f"# Version   : {h.version} ({h.date})\n"
        f"# Status    : {h.status}\n"
        "# =============================================================\n"
        "\n"
        f'SCRIPT_VER="{h.version}"\n'
        'export PATH="/jffs/scripts:/jffs/scripts/avp/bin:/opt/bin:/opt/sbin:/usr/bin:/usr/sbin:/bin:/sbin:${PATH:-}"\n'
        "hash -r 2>/dev/null || true\n"
        "set -u\n"
        "\n"
        "\n"
    )

def atomic_write(path: Path, data: str) -> None:
    tmp = path.with_name(path.name + ".meta.tmp")
    tmp.write_text(data, encoding="utf-8")
    os.chmod(tmp, path.stat().st_mode if path.exists() else 0o755)
    os.replace(str(tmp), str(path))

@dataclass
class SpecItem:
    path: str
    version: str
    date: str
    status: str
    component: str
    role: str
    changelog: List[str]

def load_spec(spec_path: Path) -> List[SpecItem]:
    obj = json.loads(spec_path.read_text(encoding="utf-8"))
    files = obj.get("files") or []
    out: List[SpecItem] = []
    for it in files:
        si = SpecItem(
            path=str(it["path"]),
            version=str(it["version"]),
            date=str(it["date"]),
            status=str(it.get("status", "stable")),
            component=str(it["component"]),
            role=str(it.get("role", "n/a")),
            changelog=list(it.get("changelog", [])),
        )
        validate_version(si.version)
        validate_date(si.date)
        out.append(si)
    return out

def infer_component(path: Path, fallback_component: str) -> str:
    # A2.1 fallback (safe): inferir somente quando for óbvio.
    # - avp/bin/avp-commit -> AVP-COMMIT
    # - avp/bin/avp-smoke  -> AVP-SMOKE
    # - avp/bin/avp        -> AVP-ENTRY
    n = path.name
    if path.parent.name == "bin" and path.parent.parent.name == "avp":
        if n == "avp":
            return "AVP-ENTRY"
        if n.startswith("avp-") and len(n) > 4:
            return "AVP-" + n[4:].upper()
    return fallback_component

def check_one(path: Path) -> int:
    if not path.exists():
        return die(f"{path}: arquivo não existe.", RC_FAIL)

    # changelog externo (md) NÃO é alvo governado
    if is_changelog_md(path):
        return RC_OK

    text = path.read_text(encoding="utf-8", errors="replace")
    h = parse_header(text)
    if not h:
        return die(f"{path}: header/SCRIPT_VER ausentes ou incompletos (V2).", RC_NEEDS_NORMALIZE)

    if h.version != h.script_ver:
        return die(f"{path}: mismatch Version(header)={h.version} vs SCRIPT_VER={h.script_ver}", RC_NEEDS_NORMALIZE)

    # changelog externo obrigatório p/ scripts (não para o próprio ./avp/changelog/*.md)
    if not changelog_has_entry(h.component, h.version):
        return die(f"{path}: changelog externo ausente p/ {h.component} {h.version} em {component_to_changelog(h.component)}", RC_FAIL)

    lang = detect_lang(text, path)
    if lang == "shell":
        m = re.search(r'^\s*set -u\s*$', text, re.M)
        if not m:
            return die(f"{path}: shell sem 'set -u'.", RC_NEEDS_NORMALIZE)
        tail = text[m.end():]
        if not re.match(r'^\s*\n\s*\n', tail):
            return die(f"{path}: shell sem 2 linhas em branco após 'set -u'.", RC_NEEDS_NORMALIZE)

    return RC_OK

def normalize_one(path: Path, fallback_component: str, fallback_role: str, fallback_status: str) -> int:
    if is_changelog_md(path):
        return RC_OK

    text = path.read_text(encoding="utf-8", errors="replace") if path.exists() else ""
    lang = detect_lang(text, path)
    shebang, body = split_body(text, lang)

    h = parse_header(text)

    # A2.1 fallback: se não tem header, tenta criar baseado no SCRIPT_VER e inferência do componente.
    if not h:
        msv = SCRIPT_VER_RE.search(text or "")
        if not msv:
            return die(f"{path}: sem header e sem SCRIPT_VER; use --apply via spec.", RC_FAIL)
        ver = msv.group(1).strip()
        try:
            validate_version(ver)
        except Exception:
            return die(f"{path}: SCRIPT_VER inválido para fallback: {ver}", RC_FAIL)

        today = _dt.datetime.now().strftime("%Y-%m-%d")
        comp = infer_component(path, fallback_component)
        h = HeaderInfo(
            component=comp or fallback_component,
            file=path.name,
            role=(fallback_role or "n/a"),
            status=(fallback_status or "stable"),
            version=ver,
            date=today,
            script_ver=ver,
        )

    hdr = build_header(lang, h)

    out = ""
    if shebang:
        out += shebang
    else:
        out += "#!/opt/bin/python3\n" if lang == "python" else "#!/bin/sh\n"
    out += hdr
    out += body.lstrip("\n")

    atomic_write(path, out)
    return RC_OK

def cmd_print_spec_template() -> int:
    tmpl = {
        "files": [
            {
                "path": "avp/bin/avp-meta",
                "version": SCRIPT_VER,
                "date": _dt.datetime.now().strftime("%Y-%m-%d"),
                "status": "stable",
                "component": "AVP-META",
                "role": "Metadata governor (V2-only: header + SCRIPT_VER + external changelog)",
                "changelog": ["- ADD: example bullet"],
            }
        ]
    }
    print(json.dumps(tmpl, indent=2))
    return RC_OK

def cmd_check(targets: List[str]) -> int:
    rc = RC_OK
    for t in targets:
        p = (REPO_ROOT / t).resolve() if not Path(t).is_absolute() else Path(t)
        r = check_one(p)
        rc = max(rc, r)
    return rc

def cmd_normalize(targets: List[str]) -> int:
    rc = RC_OK
    for t in targets:
        p = (REPO_ROOT / t).resolve() if not Path(t).is_absolute() else Path(t)
        r = normalize_one(p, "AVP-UNK", "n/a", "stable")
        rc = max(rc, r)
    return rc

def cmd_apply(spec: Path) -> int:
    items = load_spec(spec)
    for it in items:
        upsert_changelog_entry(it.component, it.version, it.date, it.changelog)

    for it in items:
        p = (REPO_ROOT / it.path).resolve() if not Path(it.path).is_absolute() else Path(it.path)
        if not p.exists():
            return die(f"{it.path}: arquivo não existe (spec).", RC_FAIL)

        text = p.read_text(encoding="utf-8", errors="replace")
        lang = detect_lang(text, p)
        shebang, body = split_body(text, lang)

        h = HeaderInfo(
            component=it.component,
            file=p.name,
            role=it.role or "n/a",
            status=it.status,
            version=it.version,
            date=it.date,
            script_ver=it.version,
        )

        hdr = build_header(lang, h)
        out = (shebang or ("#!/opt/bin/python3\n" if lang == "python" else "#!/bin/sh\n")) + hdr + body.lstrip("\n")
        atomic_write(p, out)

        if not changelog_has_entry(it.component, it.version, it.date):
            return die(f"{it.path}: falha ao registrar changelog externo {it.component} {it.version} ({it.date})", RC_FAIL)

    log(f"OK: apply spec={spec}")
    return RC_OK

def build_argp() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(prog="avp-meta", add_help=False)
    p.add_argument("--help", action="store_true")
    p.add_argument("--print-spec-template", action="store_true")
    p.add_argument("--check", action="store_true")
    p.add_argument("--normalize", action="store_true")
    p.add_argument("--apply", action="store_true")
    p.add_argument("--spec", type=str, default="")
    p.add_argument("--targets", nargs="*", default=[])
    return p

def main(argv: List[str]) -> int:
    ns = build_argp().parse_args(argv)

    if ns.help or (not ns.print_spec_template and not ns.check and not ns.normalize and not ns.apply):
        print(
            "Usage:\n"
            "  avp-meta --help\n"
            "  avp-meta --print-spec-template\n\n"
            "  avp-meta --check --targets [...]\n"
            "  avp-meta --normalize --targets [...]\n"
            "  avp-meta --apply --spec /caminho/spec.json\n\n"
            "Notas:\n"
            "- V2-only: scripts NÃO possuem bloco CHANGELOG interno.\n"
            "- CHANGELOG externo por componente em ./avp/changelog/*.md\n"
            "- avp/changelog/*.md NÃO é alvo governado (meta ignora).\n"
            "- A2.1 fallback: normalize cria header quando faltar (se houver SCRIPT_VER).\n"
        )
        return RC_OK

    if ns.print_spec_template:
        return cmd_print_spec_template()

    if ns.check:
        if not ns.targets:
            return die("--check requer --targets", RC_FAIL)
        return cmd_check(ns.targets)

    if ns.normalize:
        if not ns.targets:
            return die("--normalize requer --targets", RC_FAIL)
        return cmd_normalize(ns.targets)

    if ns.apply:
        if not ns.spec:
            return die("--apply requer --spec", RC_FAIL)
        return cmd_apply(Path(ns.spec))

    return die("modo inválido", RC_FAIL)

if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
