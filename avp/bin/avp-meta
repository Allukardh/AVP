#!/opt/bin/python3
from __future__ import annotations

# =============================================================
# AutoVPN Platform (AVP)
# Component : AVP-META
# File      : avp-meta
# Role      : Metadata governor (V2-only: header + SCRIPT_VER + external changelog) + register helper
# Version   : v1.1.0 (2026-02-18)
# Status    : stable
# =============================================================

SCRIPT_VER="v1.1.0"

import argparse
import datetime as _dt
import json
import os
import re
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional, Tuple

RC_OK = 0
RC_FAIL = 1
RC_NEEDS_NORMALIZE = 2

SELF = Path(__file__).resolve()
AVP_ROOT = SELF.parents[1]      # .../avp
REPO_ROOT = SELF.parents[2]     # .../jffs/scripts
CHANGELOG_DIR = AVP_ROOT / "changelog"
LOG_DIR = AVP_ROOT / "logs"
LOG_FILE = LOG_DIR / "avp_meta.log"

_VERSION_RE = re.compile(r"^v\d+\.\d+\.\d+$")
_DATE_RE = re.compile(r"^\d{4}-\d{2}-\d{2}$")

HDR_KV_RE: Dict[str, re.Pattern] = {
    "component": re.compile(r"^\s*#\s*Component\s*:\s*(.+?)\s*$", re.M),
    "file":      re.compile(r"^\s*#\s*File\s*:\s*(.+?)\s*$", re.M),
    "role":      re.compile(r"^\s*#\s*Role\s*:\s*(.+?)\s*$", re.M),
    "status":    re.compile(r"^\s*#\s*Status\s*:\s*(.+?)\s*$", re.M),
    "version":   re.compile(r"^\s*#\s*Version\s*:\s*(v\d+\.\d+\.\d+)\s*\((\d{4}-\d{2}-\d{2})\)\s*$", re.M),
}
SCRIPT_VER_RE = re.compile(r'^\s*SCRIPT_VER\s*=\s*"?\s*(v\d+\.\d+\.\d+)\s*"?\s*$', re.M)

def _ts() -> str:
    return _dt.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

def want_json() -> bool:
    v = (os.environ.get("AVP_JSON") or "").strip().lower()
    return v in ("1", "true", "yes", "on")

def _log_line(msg: str) -> str:
    return f"{_ts()} [META] {msg}"

def log(msg: str) -> None:
    line = _log_line(msg)
    if want_json():
        sys.stderr.write(line + "\n")
    else:
        print(line)
    try:
        LOG_DIR.mkdir(parents=True, exist_ok=True)
        with LOG_FILE.open("a", encoding="utf-8") as f:
            f.write(line + "\n")
    except Exception:
        pass

def err(msg: str) -> None:
    sys.stderr.write(_log_line("ERR: " + msg) + "\n")

def die(msg: str, rc: int = RC_FAIL) -> int:
    err(msg)
    return rc

def jdump(obj: dict) -> None:
    # stdout limpo: só JSON
    sys.stdout.write(json.dumps(obj, ensure_ascii=False, separators=(",", ":")) + "\n")

def validate_version(v: str) -> None:
    if not _VERSION_RE.match(v):
        raise ValueError(f"version inválida: {v} (esperado vX.Y.Z)")

def validate_date(d: str) -> None:
    if not _DATE_RE.match(d):
        raise ValueError(f"date inválida: {d} (esperado YYYY-MM-DD)")

def is_changelog_md(path: Path) -> bool:
    try:
        rp = path.resolve()
    except Exception:
        rp = path
    return (CHANGELOG_DIR in rp.parents) and rp.suffix.lower() == ".md"

def detect_lang(text: str, path: Path) -> str:
    if text.startswith("#!") and "python" in text.splitlines()[0]:
        return "python"
    if text.startswith("#!"):
        return "shell"
    if path.parent.name == "bin" and path.parent.parent.name == "avp":
        return "python"
    return "shell"

@dataclass
class HeaderInfo:
    component: str
    file: str
    role: str
    status: str
    version: str
    date: str
    script_ver: str

def parse_header(text: str) -> Optional[HeaderInfo]:
    mver = HDR_KV_RE["version"].search(text)
    msv = SCRIPT_VER_RE.search(text)
    if not mver or not msv:
        return None

    def _get(key: str) -> str:
        m = HDR_KV_RE[key].search(text)
        return (m.group(1).strip() if m else "")

    component = _get("component")
    file_ = _get("file")
    role = _get("role")
    status = _get("status")
    version = mver.group(1).strip()
    date = mver.group(2).strip()
    script_ver = msv.group(1).strip()

    if not component or not file_ or not status:
        return None
    return HeaderInfo(component, file_, role or "n/a", status, version, date, script_ver)

def component_to_changelog(component: str) -> Path:
    c = component.strip().upper()
    slug = c[4:].lower() if c.startswith("AVP-") else c.lower()
    if slug in ("git", "gitops"):
        slug = "gitops"
    if slug in ("boot", "hook", "hooks"):
        slug = "hooks"
    return CHANGELOG_DIR / f"{slug}.md"

def ensure_changelog(component: str) -> Path:
    CHANGELOG_DIR.mkdir(parents=True, exist_ok=True)
    p = component_to_changelog(component)
    if not p.exists():
        p.write_text(f"# {component.strip().upper()}\n", encoding="utf-8")
    return p

def changelog_has_entry(component: str, version: str, date: Optional[str] = None) -> bool:
    p = component_to_changelog(component)
    if not p.exists():
        return False
    txt = p.read_text(encoding="utf-8", errors="replace")
    if date:
        return f"## {version} ({date})" in txt
    return re.search(
        rf"^##\s+{re.escape(version)}\s+\(\d{{4}}-\d{{2}}-\d{{2}}\)\s*$",
        txt,
        re.M
    ) is not None

def upsert_changelog_entry(component: str, version: str, date: str, bullets: List[str]) -> None:
    validate_version(version)
    validate_date(date)

    p = ensure_changelog(component)
    txt = p.read_text(encoding="utf-8", errors="replace")
    lines = txt.splitlines()

    if not lines or not lines[0].startswith("# "):
        lines = [f"# {component.strip().upper()}", ""]

    header = f"## {version} ({date})"

    norm: List[str] = []
    for b in bullets:
        b = (b or "").strip()
        if not b:
            continue
        if b.startswith("- "):
            norm.append(b)
        elif b.startswith("* "):
            norm.append("- " + b[2:].strip())
        else:
            norm.append("- " + b)

    if not norm:
        return

    sec = None
    for i, ln in enumerate(lines):
        if ln.strip() == header:
            sec = i
            break

    if sec is None:
        # insert right after title block
        insert_at = 1
        if len(lines) == 1:
            lines.append("")
        if lines[1].strip() != "":
            lines.insert(1, "")
        insert_at = 2
        block = [header] + norm + [""]
        lines[insert_at:insert_at] = block
    else:
        end = sec + 1
        while end < len(lines) and not lines[end].startswith("## "):
            end += 1
        existing = set(
            ln.strip() for ln in lines[sec+1:end]
            if ln.strip().startswith("- ")
        )
        add = [b for b in norm if b.strip() not in existing]
        if add:
            lines[sec+1:sec+1] = add
        if end <= len(lines) and (end == len(lines) or lines[end-1].strip() != ""):
            lines.insert(end, "")

    p.write_text("\n".join(lines).rstrip() + "\n", encoding="utf-8")

def split_body(text: str, lang: str) -> Tuple[str, str]:
    lines = text.splitlines(keepends=True)
    if not lines:
        return ("", "")
    shebang = ""
    i = 0
    if lines[0].startswith("#!"):
        shebang = lines[0]
        i = 1

    sv_line = None
    for j in range(i, min(len(lines), i + 300)):
        if lines[j].lstrip().startswith("SCRIPT_VER"):
            sv_line = j
            break

    if sv_line is None:
        return (shebang, "".join(lines[i:]))

    if lang == "python":
        k = sv_line + 1
        while k < len(lines) and lines[k].strip() == "":
            k += 1
        return (shebang, "".join(lines[k:]))

    setu = None
    for j in range(sv_line + 1, min(len(lines), sv_line + 160)):
        if lines[j].strip() == "set -u":
            setu = j
            break
    if setu is None:
        return (shebang, "".join(lines[sv_line+1:]))

    m = setu + 1
    while m < len(lines) and lines[m].strip() == "":
        m += 1
    return (shebang, "".join(lines[m:]))

def build_header(lang: str, h: HeaderInfo) -> str:
    if lang == "python":
        return (
            "# =============================================================\n"
            "# AutoVPN Platform (AVP)\n"
            f"# Component : {h.component}\n"
            f"# File      : {h.file}\n"
            f"# Role      : {h.role}\n"
            f"# Version   : {h.version} ({h.date})\n"
            f"# Status    : {h.status}\n"
            "# =============================================================\n"
            "\n"
            f'SCRIPT_VER="{h.version}"\n'
            "\n"
        )

    return (
        "# =============================================================\n"
        "# AutoVPN Platform (AVP)\n"
        f"# Component : {h.component}\n"
        f"# File      : {h.file}\n"
        f"# Role      : {h.role}\n"
        f"# Version   : {h.version} ({h.date})\n"
        f"# Status    : {h.status}\n"
        "# =============================================================\n"
        "\n"
        f'SCRIPT_VER="{h.version}"\n'
        'export PATH="/jffs/scripts:/jffs/scripts/avp/bin:/opt/bin:/opt/sbin:/usr/bin:/usr/sbin:/bin:/sbin:${PATH:-}"\n'
        "hash -r 2>/dev/null || true\n"
        "set -u\n"
        "\n"
        "\n"
    )

def atomic_write(path: Path, data: str) -> None:
    tmp = path.with_name(path.name + ".meta.tmp")
    tmp.write_text(data, encoding="utf-8")
    os.chmod(tmp, path.stat().st_mode if path.exists() else 0o755)
    os.replace(str(tmp), str(path))

@dataclass
class SpecItem:
    path: str
    version: str
    date: str
    status: str
    component: str
    role: str
    changelog: List[str]

def load_spec(spec_path: Path) -> List[SpecItem]:
    obj = json.loads(spec_path.read_text(encoding="utf-8"))
    files = obj.get("files") or []
    out: List[SpecItem] = []
    for it in files:
        si = SpecItem(
            path=str(it["path"]),
            version=str(it["version"]),
            date=str(it["date"]),
            status=str(it.get("status", "stable")),
            component=str(it["component"]),
            role=str(it.get("role", "n/a")),
            changelog=list(it.get("changelog", [])),
        )
        validate_version(si.version)
        validate_date(si.date)
        out.append(si)
    return out

def run_git(args: List[str]) -> Tuple[int, str]:
    try:
        r = subprocess.run(
            ["/opt/bin/git"] + args if Path("/opt/bin/git").exists() else ["git"] + args,
            cwd=str(REPO_ROOT),
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            check=False,
        )
        return r.returncode, (r.stdout or "")
    except Exception as ex:
        return 126, f"git exception: {ex}"

def governed_relpaths(paths: List[str]) -> List[str]:
    out: List[str] = []
    for rel in paths:
        rel = rel.strip().lstrip("/")
        if not rel:
            continue
        # core python tools
        if rel.startswith("avp/bin/"):
            out.append(rel); continue
        # shared python libs
        if rel.startswith("avp/lib/") and rel.endswith(".py"):
            out.append(rel); continue
        # merlin hooks
        if rel in ("services-start", "post-mount", "service-event"):
            out.append(rel); continue
        # webui
        if rel.startswith("avp/www/") and rel.endswith(".asp"):
            out.append(rel); continue
    return sorted(set(out))

def check_one(path: Path) -> int:
    if not path.exists():
        return die(f"{path}: arquivo não existe.", RC_FAIL)

    # changelog externo (.md) NÃO é alvo governado
    if is_changelog_md(path):
        return RC_OK

    text = path.read_text(encoding="utf-8", errors="replace")
    h = parse_header(text)
    if not h:
        return die(f"{path}: header/SCRIPT_VER ausentes ou incompletos (V2).", RC_NEEDS_NORMALIZE)

    if h.version != h.script_ver:
        return die(f"{path}: mismatch Version(header)={h.version} vs SCRIPT_VER={h.script_ver}", RC_NEEDS_NORMALIZE)

    if not changelog_has_entry(h.component, h.version):
        return die(
            f"{path}: changelog externo ausente p/ {h.component} {h.version} em {component_to_changelog(h.component)}",
            RC_FAIL
        )

    lang = detect_lang(text, path)
    if lang == "shell":
        m = re.search(r'^\s*set -u\s*$', text, re.M)
        if not m:
            return die(f"{path}: shell sem 'set -u'.", RC_NEEDS_NORMALIZE)
        tail = text[m.end():]
        if not re.match(r'^\s*\n\s*\n', tail):
            return die(f"{path}: shell sem 2 linhas em branco após 'set -u'.", RC_NEEDS_NORMALIZE)

    return RC_OK

def normalize_one(path: Path, explicit: Optional[HeaderInfo]) -> int:
    if is_changelog_md(path):
        return RC_OK

    text = path.read_text(encoding="utf-8", errors="replace") if path.exists() else ""
    lang = detect_lang(text, path)
    shebang, body = split_body(text, lang)
    h = parse_header(text)

    if h is None:
        if explicit is None:
            return die(f"{path}: sem header; para normalizar, forneça --component/--file/--role/--version/--date/--status.", RC_NEEDS_NORMALIZE)
        h = explicit

    # (sem fallback A2.1) — usa o header existente (ou explicit) e reescreve o topo
    data = ""
    if shebang:
        data += shebang.rstrip("\n") + "\n"
    data += build_header(lang, HeaderInfo(
        component=h.component,
        file=h.file,
        role=h.role,
        status=h.status,
        version=h.version,
        date=h.date,
        script_ver=h.version,
    ))
    data += body

    atomic_write(path, data)
    return RC_OK

def apply_spec(spec_path: Path) -> int:
    items = load_spec(spec_path)
    for it in items:
        upsert_changelog_entry(it.component, it.version, it.date, it.changelog)
    return RC_OK

def register_files(relpaths: List[str], msgs: List[str]) -> int:
    if not msgs:
        return die("register exige ao menos 1 --msg (sem auto-msg).", RC_FAIL)

    changed: List[str] = []
    for rel in relpaths:
        p = (REPO_ROOT / rel)
        if not p.exists():
            return die(f"alvo não existe: {rel}", RC_FAIL)
        if is_changelog_md(p):
            continue

        text = p.read_text(encoding="utf-8", errors="replace")
        h = parse_header(text)
        if not h:
            return die(f"{rel}: header/SCRIPT_VER ausentes (registre só após normalizar).", RC_FAIL)

        if h.version != h.script_ver:
            return die(f"{rel}: mismatch header {h.version} vs SCRIPT_VER {h.script_ver}", RC_FAIL)

        upsert_changelog_entry(h.component, h.version, h.date, msgs)
        changed.append(rel)

    if want_json():
        jdump({
            "component":"AVP-META",
            "version":SCRIPT_VER,
            "action":"register",
            "rc":0,
            "targets":changed,
        })
    else:
        log("OK: register " + " ".join(changed) if changed else "OK: register (no targets)")
    return RC_OK

def main(argv: List[str]) -> int:
    ap = argparse.ArgumentParser(prog="avp-meta", add_help=False)

    ap.add_argument("--help", action="store_true")
    ap.add_argument("--check", action="store_true")
    ap.add_argument("--normalize", action="store_true")
    ap.add_argument("--apply", action="store_true")
    ap.add_argument("--spec", type=str, default="")

    # register helper (A/C)
    ap.add_argument("--register", action="store_true", help="registrar changelog externo baseado no header do(s) alvo(s)")
    ap.add_argument("--staged", action="store_true", help="(register) usa arquivos staged (git diff --name-only --cached)")
    ap.add_argument("--msg", action="append", default=[], help="(register) bullet(s) do changelog (repita --msg)")

    ap.add_argument("--targets", nargs="*", default=[])

    # normalize explicit metadata (somente se alvo não tem header)
    ap.add_argument("--component", type=str, default="")
    ap.add_argument("--file", type=str, default="")
    ap.add_argument("--role", type=str, default="")
    ap.add_argument("--version", type=str, default="")
    ap.add_argument("--date", type=str, default="")
    ap.add_argument("--status", type=str, default="")

    ns = ap.parse_args(argv)

    if ns.help or (not ns.check and not ns.normalize and not ns.apply and not ns.register):
        print(
            "Usage:\n"
            "  avp-meta --check --targets <relpaths...>\n"
            "  avp-meta --normalize --targets <relpaths...> [--component ... --file ... --role ... --version ... --date ... --status ...]\n"
            "  avp-meta --apply --spec <file.json>\n"
            "\n"
            "Register helper (ergonomia):\n"
            "  avp-meta --register --targets <relpaths...> --msg \"...\" [--msg \"...\"]\n"
            "  avp-meta --register --staged --msg \"...\" [--msg \"...\"]\n"
            "\n"
            "Notes:\n"
            "- V2: changelog é externo em ./avp/changelog/*.md\n"
            "- Sem auto-msg: --msg é obrigatório no --register.\n"
            "- Sem fallback: meta não infere componente se faltar header; normalize exige metadata explícita.\n"
            "- AVP_JSON=1 => stdout JSON limpo; logs no stderr.\n"
        )
        return RC_OK

    if ns.apply:
        if not ns.spec:
            return die("--apply exige --spec <json>", RC_FAIL)
        rc = apply_spec(Path(ns.spec))
        if want_json():
            jdump({"component":"AVP-META","version":SCRIPT_VER,"action":"apply","rc":rc,"spec":ns.spec})
        else:
            log(f"OK: apply spec={ns.spec}" if rc == 0 else f"FAIL: apply spec={ns.spec}")
        return rc

    if ns.register:
        rels: List[str] = []
        if ns.staged:
            rc, out = run_git(["diff", "--name-only", "--cached"])
            if rc != 0:
                return die("falha ao ler staged (git diff --cached).", RC_FAIL)
            rels = governed_relpaths([ln.strip() for ln in out.splitlines() if ln.strip()])
        else:
            rels = governed_relpaths(ns.targets)

        if not rels:
            return die("register: nenhum alvo governado encontrado (use --targets ou --staged).", RC_FAIL)

        return register_files(rels, ns.msg)

    # check / normalize
    rels = governed_relpaths(ns.targets)
    if not rels:
        return die("nenhum alvo governado em --targets.", RC_FAIL)

    explicit: Optional[HeaderInfo] = None
    if ns.normalize:
        if ns.component or ns.file or ns.role or ns.version or ns.date or ns.status:
            # exige tudo se for usar explicit
            if not (ns.component and ns.file and ns.version and ns.date and ns.status):
                return die("normalize explicit exige: --component --file --version --date --status (role opcional).", RC_FAIL)
            validate_version(ns.version)
            validate_date(ns.date)
            explicit = HeaderInfo(
                component=ns.component,
                file=ns.file,
                role=ns.role or "n/a",
                status=ns.status,
                version=ns.version,
                date=ns.date,
                script_ver=ns.version,
            )

    worst = RC_OK
    for rel in rels:
        p = (REPO_ROOT / rel)
        if ns.check:
            worst = max(worst, check_one(p))
        if ns.normalize:
            worst = max(worst, normalize_one(p, explicit))

    if want_json():
        jdump({
            "component":"AVP-META",
            "version":SCRIPT_VER,
            "action":"check" if ns.check else "normalize",
            "rc":worst,
            "targets":rels,
        })
    else:
        if worst == RC_OK:
            log("OK")
        else:
            err("FAIL")
    return worst

if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
