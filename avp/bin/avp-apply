#!/opt/bin/python3
from __future__ import annotations

# =============================================================
# AutoVPN Platform (AVP)
# Component : AVP-APPLY
# File      : avp-apply
# Role      : Patch apply helper (V2-only: external changelog; meta checks best-effort)
# Version   : v2.0.0 (2026-02-17)
# Status    : stable
# =============================================================

SCRIPT_VER="v2.0.0"

import argparse
import datetime as _dt
import os
import subprocess
import sys
from pathlib import Path
from typing import List


SELF = Path(__file__).resolve()
AVP_ROOT = SELF.parents[1]      # .../avp
REPO_ROOT = SELF.parents[2]     # .../jffs/scripts
LOG_DIR = AVP_ROOT / "logs"
LOG_FILE = LOG_DIR / "avp_apply.log"
META_BIN = REPO_ROOT / "avp/bin/avp-meta"


def ts() -> str:
    return _dt.datetime.now().strftime("%Y-%m-%d %H:%M:%S")


def log(msg: str) -> None:
    line = f"{ts()} [APPLY] {msg}"
    print(line)
    try:
        LOG_DIR.mkdir(parents=True, exist_ok=True)
        LOG_FILE.write_text(LOG_FILE.read_text(encoding="utf-8", errors="ignore") + line + "\n", encoding="utf-8")
    except Exception:
        try:
            LOG_DIR.mkdir(parents=True, exist_ok=True)
            with LOG_FILE.open("a", encoding="utf-8") as f:
                f.write(line + "\n")
        except Exception:
            pass


def run(cmd: List[str], check: bool = True, capture: bool = False) -> subprocess.CompletedProcess:
    log("RUN: " + " ".join(cmd))
    return subprocess.run(
        cmd,
        cwd=str(REPO_ROOT),
        check=check,
        text=True,
        stdout=subprocess.PIPE if capture else None,
        stderr=subprocess.STDOUT if capture else None,
    )


def git(cmd: List[str], check: bool = True, capture: bool = False) -> subprocess.CompletedProcess:
    return run(["git"] + cmd, check=check, capture=capture)


def list_patch_files(patch: Path) -> List[str]:
    # tenta obter lista de arquivos afetados por "git apply --numstat"
    try:
        out = git(["apply", "--numstat", str(patch)], check=True, capture=True).stdout or ""
        files = []
        for ln in out.splitlines():
            parts = ln.split("\t")
            if len(parts) >= 3:
                files.append(parts[2].strip())
        return sorted(set(f for f in files if f))
    except Exception:
        return []


def meta_check(files: List[str]) -> None:
    if not META_BIN.exists() or not os.access(META_BIN, os.X_OK):
        log("WARN: avp-meta não encontrado/executável; pulando meta check.")
        return
    for f in files:
        p = REPO_ROOT / f
        if not p.exists():
            continue
        # best-effort: só roda e loga; não mata apply por causa disso
        try:
            subprocess.run(
                [str(META_BIN), "--check", "--targets", f],
                cwd=str(REPO_ROOT),
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                check=False,
                text=True,
            )
        except Exception:
            pass


def main(argv: List[str]) -> int:
    ap = argparse.ArgumentParser(prog="avp-apply")
    ap.add_argument("patches", nargs="+", help="arquivo(s) .patch para aplicar")
    ap.add_argument("--3way", action="store_true", help="tenta git apply --3way")
    ap.add_argument("--check-only", action="store_true", help="somente valida (git apply --check), sem aplicar")
    ns = ap.parse_args(argv)

    # sanity: repo
    git(["rev-parse", "--is-inside-work-tree"], check=True)

    for p in ns.patches:
        patch = Path(p)
        if not patch.is_absolute():
            patch = (REPO_ROOT / patch).resolve()
        if not patch.exists():
            log(f"ERR: patch não existe: {patch}")
            return 2

        # 1) check
        log(f"CHECK: {patch}")
        git(["apply", "--check", str(patch)], check=True)

        if ns.check_only:
            log(f"OK(check-only): {patch}")
            continue

        # 2) apply
        cmd = ["apply"]
        if ns.__dict__.get("3way"):
            cmd += ["--3way"]
        cmd += [str(patch)]
        log(f"APPLY: {patch}")
        git(cmd, check=True)

        # 3) meta checks best-effort nos arquivos afetados
        files = list_patch_files(patch)
        if files:
            log("AFFECTED: " + " ".join(files))
        meta_check(files)

        log(f"OK: applied {patch}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
