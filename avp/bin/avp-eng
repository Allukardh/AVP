#!/opt/bin/python3
# =============================================================
# AutoVPN Platform (AVP)
# Component : AVP-ENG
# File      : avp-eng
# Role      : Multi-Device VPN Failover (Engine) â€” Python native
# Version   : v2.3.0 (2026-02-20)
# Status    : experimental
# =============================================================
SCRIPT_VER = "v2.3.0"

import os
import sys
import time
import subprocess
import re
import json
from pathlib import Path
import sys
SELF = Path(__file__).resolve()
REPO_ROOT = SELF.parents[2]
if str(REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(REPO_ROOT))
from avp.lib.avp_lib import log_event, log_error, state_get, state_set, avp_epoch

# Directories / constants
CANON_BASE = "/jffs/scripts"
STATE_DIR = f"{CANON_BASE}/avp/state"
POLICY_DIR = f"{CANON_BASE}/avp/policy"
DEVICES_CONF = f"{POLICY_DIR}/devices.conf"
WGS = ["wgc1","wgc2","wgc3","wgc4","wgc5"]
PING_TARGETS = ["1.1.1.1","8.8.8.8"]
PING_COUNT = 2
PING_W = 2
HANDSHAKE_MAX_AGE = 180
DWARN_TTL = 300  # degrade TTL in seconds

def load_devices():
    devices = []
    if not os.path.isfile(DEVICES_CONF):
        log_error("ENG","devices.conf ausente",rc=20)
        return devices
    with open(DEVICES_CONF) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            parts = line.split()
            if len(parts) < 3:
                continue
            label, ip, pref = parts[:3]
            sl = re.sub(r'[^A-Za-z0-9]+','_',label.lower()).strip('_') or 'device'
            statefile = f"{STATE_DIR}/avp_{sl}.state"
            devices.append((label,ip,pref,statefile))
    return devices

def handshake_age(iface):
    try:
        now = int(time.time())
        proc = subprocess.run(["wg","show",iface,"latest-handshakes"], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, text=True)
        ages = []
        for line in proc.stdout.strip().split("\n"):
            parts = line.split()
            if len(parts)>=2:
                try:
                    ts = int(parts[1])
                    if ts>0:
                        ages.append(now-ts)
                except ValueError:
                    pass
        if ages: return max(ages)
    except Exception: pass
    return None

def ping_iface(iface,target):
    try:
        cmd=["ping","-I",iface,"-c",str(PING_COUNT),"-W",str(PING_W),target]
        proc = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, text=True)
        if proc.returncode != 0:
            return None
        match = re.search(r"min/avg/max/[\\w]+=([0-9.]+)/([0-9.]+)/([0-9.]+)", proc.stdout)
        if match:
            return float(match.group(2))
    except Exception: pass
    return None

def _degrade_ts_key(iface):
    return f"d_warn_ts_{iface}"

def is_degraded(iface):
    ts_str = state_get(_degrade_ts_key(iface))
    if not ts_str:
        return False
    try:
        ts=int(ts_str)
    except Exception:
        return False
    now = avp_epoch()
    if now - ts >= DWARN_TTL:
        # TTL expired -> clear
        state_set(_degrade_ts_key(iface),"0")
        return False
    return True

def mark_degraded(iface):
    now = avp_epoch()
    state_set(_degrade_ts_key(iface), str(now))

def score_iface(iface):
    # down? huge penalty
    ilink = subprocess.run(["ip","link","show",iface], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, text=True)
    if "UP" not in ilink.stdout:
        return (99999,f"{iface}:DOWN")
    if is_degraded(iface):
        return (9999,f"{iface}:DEGRADED")
    age = handshake_age(iface)
    if age is None:
        # no handshake -> degrade
        mark_degraded(iface)
        return (9999,f"{iface}:NOHS")
    if age > HANDSHAKE_MAX_AGE:
        mark_degraded(iface)
        return (9999,f"{iface}:AGE>{HANDSHAKE_MAX_AGE}")
    rtts=[]
    for t in PING_TARGETS:
        r=ping_iface(iface,t)
        if r is not None:
            rtts.append(r)
    if not rtts:
        # no reachable target
        mark_degraded(iface)
        return (9999,f"{iface}:PINGFAIL")
    rtt_score=sum(rtts)/len(rtts)
    score=int(age + rtt_score)
    return (score,f"{iface}:age={age}s rtt={rtt_score:.2f}")

def apply_route(device, table):
    label, ip, pref, statefile = device
    pref_num = pref
    if table == "vpn":
        tbl=pref_num
        cmds = [
            ["ip","rule","delete","pref",pref_num],
            ["ip","rule","add","pref",pref_num,"from",ip,"lookup",tbl],
            ["ip","route","flush","cache"]
        ]
        for cmd in cmds: subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        state_set("dev_mode","vpn")
    else:
        subprocess.run(["ip","rule","delete","pref",pref_num], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        subprocess.run(["ip","route","flush","cache"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        state_set("dev_mode","wan")

def run_engine():
    devices=load_devices()
    if not devices:
        return 20
    for device in devices:
        label, ip, pref, statefile = device
        cur_mode=state_get("dev_mode") or "unknown"
        log_event("ENG",f"[{label}] cur_mode={cur_mode}",rc=0)
        scores=[]
        for wg in WGS:
            sc,desc=score_iface(wg)
            scores.append((sc,wg,desc))
            log_event("ENG",f"[{label}] score {desc} -> {sc}",rc=0)
        scores.sort(key=lambda x:x[0])
        best_sc,best_wg,best_desc=scores[0]
        log_event("ENG",f"[{label}] best {best_wg} score={best_sc}",rc=0)
        if best_sc<9999:
            if cur_mode!="vpn":
                apply_route(device,"vpn")
        else:
            if cur_mode!="wan":
                apply_route(device,"wan")
    return 0

def status_engine():
    out={}
    devices=load_devices()
    if not devices:
        return json.dumps({"error":"no devices"})
    results=[]
    cur_mode=state_get("dev_mode") or "unknown"
    out["cur_mode"]=cur_mode
    for device in devices:
        label, ip, pref, statefile = device
        dev_info={"label":label,"ip":ip,"pref":pref}
        sc_list=[]
        for wg in WGS:
            sc,desc=score_iface(wg)
            sc_list.append({"iface":wg,"score":sc,"desc":desc})
        sc_list.sort(key=lambda x:x["score"])
        dev_info["best_iface"]=sc_list[0]["iface"]
        dev_info["best_score"]=sc_list[0]["score"]
        dev_info["ifaces"]=sc_list
        results.append(dev_info)
    out["devices"]=results
    return json.dumps(out)

def main(argv):
    if not argv:
        print("Usage: avp-eng [run|status]")
        return 0
    cmd=argv[0]
    if cmd=="run":
        return run_engine()
    if cmd=="status":
        print(status_engine())
        return 0
    print("Usage: avp-eng [run|status]")
    return 1

if __name__=="__main__":
    sys.exit(main(sys.argv[1:]))
