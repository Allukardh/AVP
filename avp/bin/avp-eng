#!/opt/bin/python3
# =============================================================
# AutoVPN Platform (AVP)
# Component : AVP-ENG
# File      : avp-eng
# Role      : Multi-Device VPN Failover (Engine) — Python native
# Version   : v2.2.0 (2026-02-20)
# Status    : experimental
# =============================================================
SCRIPT_VER = "v2.2.0"

import os
import sys
import time
import subprocess
import re
from pathlib import Path
from typing import List, Tuple, Optional
from avp.lib.avp_lib import log_event, log_error, state_get, state_set

# Configurações básicas
CANON_BASE = "/jffs/scripts"
STATE_DIR = f"{CANON_BASE}/avp/state"
POLICY_DIR = f"{CANON_BASE}/autovpn/policy"
DEVICES_CONF = f"{POLICY_DIR}/devices.conf"
WGS = ["wgc1", "wgc2", "wgc3", "wgc4", "wgc5"]
PING_TARGETS = ["1.1.1.1", "8.8.8.8"]
PING_COUNT = 2
PING_W = 2
HANDSHAKE_MAX_AGE = 180  # segundos

def load_devices() -> List[Tuple[str, str, str, str]]:
    """Carrega devices.conf retornando lista de (label, ip, pref, statefile)."""
    devices: List[Tuple[str, str, str, str]] = []
    if not os.path.isfile(DEVICES_CONF):
        log_error("ENG", f"devices.conf ausente: {DEVICES_CONF}", rc=20)
        return devices
    with open(DEVICES_CONF) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            parts = line.split()
            if len(parts) < 3:
                continue
            label, ip, pref = parts[:3]
            sl = re.sub(r'[^A-Za-z0-9]+', '_', label.strip().lower()).strip('_') or 'device'
            statefile = f"{STATE_DIR}/avp_{sl}.state"
            devices.append((label, ip, pref, statefile))
    return devices

def handshake_age(iface: str) -> Optional[int]:
    """Retorna idade da handshake mais recente (segundos) ou None se não houver."""
    try:
        now = int(time.time())
        proc = subprocess.run(["wg", "show", iface, "latest-handshakes"],
                              stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, text=True)
        ages = []
        for line in proc.stdout.strip().split("\n"):
            parts = line.split()
            if len(parts) >= 2:
                try:
                    ts = int(parts[1])
                    if ts > 0:
                        ages.append(now - ts)
                except ValueError:
                    pass
        if ages:
            return max(ages)
    except Exception:
        pass
    return None

def ping_iface(iface: str, target: str) -> Optional[float]:
    """Retorna média RTT (ms) de ping via interface; None se falhar."""
    try:
        cmd = ["ping", "-I", iface, "-c", str(PING_COUNT), "-W", str(PING_W), target]
        proc = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, text=True)
        if proc.returncode != 0:
            return None
        match = re.search(r"min/avg/max/[\\w]+=([0-9.]+)/([0-9.]+)/([0-9.]+)", proc.stdout)
        if match:
            avg = float(match.group(2))
            return avg
    except Exception:
        pass
    return None

def score_iface(iface: str) -> Tuple[int, str]:
    """Calcula pontuação da interface; menor é melhor. Retorna (score, desc)."""
    # Checa se interface está UP
    proc = subprocess.run(["ip", "link", "show", iface], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, text=True)
    if "UP" not in proc.stdout:
        return (99999, f"{iface}:DOWN")
    # Idade da handshake
    age = handshake_age(iface)
    if age is None:
        hs_penalty = 5000
    else:
        hs_penalty = age
    # Ping
    rtts = []
    for t in PING_TARGETS:
        rtt = ping_iface(iface, t)
        if rtt is not None:
            rtts.append(rtt)
    if not rtts:
        rtt_score = 3000
    else:
        rtt_score = sum(rtts) / len(rtts)
    score = int(hs_penalty + rtt_score)
    return score, f"{iface}:UP age={age if age is not None else 'NA'}s rtt={rtt_score:.2f}ms"

def apply_route(device: Tuple[str, str, str, str], table: str) -> bool:
    """Aplica regra de roteamento (pref) para dispositivo; table='vpn' ou 'wan'."""
    label, ip, pref, statefile = device
    pref_num = pref
    if table == "vpn":
        # Adiciona regra de roteamento via tabela de interface
        # ip rule add pref PREF from IP lookup TBL
        # ip route flush cache
        tbl = pref_num
        cmds = [
            ["ip", "rule", "delete", "pref", pref_num],
            ["ip", "rule", "add", "pref", pref_num, "from", ip, "lookup", tbl],
            ["ip", "route", "flush", "cache"],
        ]
        ok = True
        for cmd in cmds:
            subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        ok &= state_set("dev_mode", "vpn")
    else:
        # Remove regra customizada (volta pro default)
        subprocess.run(["ip", "rule", "delete", "pref", pref_num], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        subprocess.run(["ip", "route", "flush", "cache"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        ok = state_set("dev_mode", "wan")
    return ok

def run_engine() -> int:
    """Loop principal: para cada device, calcula score das interfaces e aplica melhor rota."""
    devices = load_devices()
    if not devices:
        return 20
    for device in devices:
        label, ip, pref, statefile = device
        # Carrega modo atual
        cur_mode = state_get("dev_mode") or "unknown"
        log_event("ENG", f"[{label}] cur_mode={cur_mode}", rc=0)
        scores = []
        for iface in WGS:
            sc, desc = score_iface(iface)
            scores.append((sc, iface, desc))
            log_event("ENG", f"[{label}] score {desc} -> {sc}", rc=0)
        # Escolhe melhor
        scores.sort(key=lambda x: x[0])
        best_sc, best_if, best_desc = scores[0]
        log_event("ENG", f"[{label}] best {best_if} score={best_sc}", rc=0)
        if best_sc < 99999:
            # Aplica VPN se não estamos nela
            if cur_mode != "vpn":
                apply_route(device, "vpn")
        else:
            # Sem tunel viável, fallback WAN se não estamos nele
            if cur_mode != "wan":
                apply_route(device, "wan")
    return 0

def main(argv: List[str]) -> int:
    if not argv:
        print("Usage: avp-eng <run|status|help>")
        return 0
    cmd = argv[0]
    if cmd == "run":
        return run_engine()
    elif cmd == "status":
        print("status: not yet implemented in python")
        return 0
    elif cmd in ("-h", "--help", "help"):
        print("Usage: avp-eng run")
        return 0
    else:
        return call_legacy(argv)  # fallback to legacy for unknown
    return 0

# fallback to legacy for unknown commands
def call_legacy(args: list) -> int:
    legacy = os.environ.get("AVP_ENG_SH", "/jffs/scripts/avp-eng.sh")
    if not os.path.isfile(legacy) or not os.access(legacy, os.X_OK):
        log_error("ENG", f"legacy engine not found: {legacy}", rc=127)
        return 127
    try:
        return subprocess.call([legacy] + args)
    except Exception:
        return 1

if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
