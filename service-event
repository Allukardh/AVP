#!/bin/sh
# =============================================================
# AutoVPN Platform (AVP)
# Component : AVP-WEBUI
# File      : service-event
# Role      : Firmware hook for WebUI Console actions (rc_service -> avp-action.sh)
# Version   : v1.0.6 (2026-02-20)
# Status    : stable
# =============================================================

SCRIPT_VER="v1.0.6"
export PATH="/jffs/scripts:/jffs/scripts/avp/bin:/opt/bin:/opt/sbin:/usr/bin:/usr/sbin:/bin:/sbin:${PATH:-}"
hash -r 2>/dev/null || true
set -u

LOGP="/tmp/avp_logs/avp_webui_action.log"
LAST_WWW="/www/user/avp-action-last.json"
LAST_SSOT="/jffs/scripts/avp/www/avp-action-last.json"

LAST_TMP="/tmp/var/wwwext/avp-action-last.json"
# --- AVP SSOT: last action JSON (canonical) ---
# escreve primeiro no SSOT e garante /www/user como symlink
if [ -n "${LAST_SSOT:-}" ]; then
  mkdir -p "$(dirname "$LAST_SSOT")" 2>/dev/null || true
fi

ACT="/jffs/scripts/avp/bin/avp-action.sh"
POL="/jffs/scripts/avp/bin/avp-pol.sh"

ts_h() { date '+%Y-%m-%d %H:%M:%S'; }
ts_s() { date +%s; }

log() {
  mkdir -p "/tmp/avp_logs" 2>/dev/null || true
  printf '%s | %s\n' "$(ts_h)" "${*:-}" >>"$LOGP"
}

trim() { printf "%s" "${1:-}" | tr -d '\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'; }

is_ip() { printf "%s" "${1:-}" | grep -Eq '^([0-9]{1,3}\.){3}[0-9]{1,3}$'; }

jesc() {
  printf "%s" "${1:-}" | sed \
    -e 's/\\/\\\\/g' \
    -e 's/"/\\"/g' \
    -e 's/\t/\\t/g' \
    -e 's/\r/\\r/g' \
    -e 's/\n/\\n/g'
}

json_err() {
  ok="${1:-false}"
  rc="${2:-1}"
  action="${3:-dispatch}"
  msg="${4:-error}"
  tsj="$(ts_s)"
  printf '{"ok":%s,"rc":%s,"action":"%s","msg":"%s","data":{},"ts":%s}\n' \
    "$ok" "$rc" "$(jesc "$action")" "$(jesc "$msg")" "$tsj"
}

write_last() {
  src="${1:-}"
  [ -n "${src:-}" ] || return 1
  mkdir -p "/www/user" "/tmp/var/wwwext" 2>/dev/null || true

  cp -f "$src" "$LAST_SSOT" 2>/dev/null || return 1
  chmod 0644 "$LAST_SSOT" 2>/dev/null || true

  rm -f "$LAST_WWW" "$LAST_TMP" 2>/dev/null || true;
  ln -sf "$LAST_SSOT" "$LAST_WWW" 2>/dev/null || cp -f "$LAST_SSOT" "$LAST_WWW" 2>/dev/null || true;
  ln -sf "$LAST_SSOT" "$LAST_TMP" 2>/dev/null || cp -f "$LAST_SSOT" "$LAST_TMP" 2>/dev/null || true;
  chmod 0644 "$LAST_WWW" "$LAST_TMP" 2>/dev/null || true
  return 0
}

parse_device_contract() {
  dev="$(trim "${1:-}")"
  payload="$(trim "${2:-}")"

  label=""
  ip=""
  rule=""

  # payload prefer "<ip> [rule]"
  if [ -n "${payload:-}" ]; then
    case "$payload" in
      \{*\}) : ;; # ignore JSON payload for AGORA
      *)
        set -- $payload
        if [ $# -ge 1 ] && is_ip "$1"; then
          ip="$1"
          [ $# -ge 2 ] && rule="$2"
        fi
        ;;
    esac
  fi

  # device_key accept "<label> <ip> [rule]" or "<label>"
  if [ -n "${dev:-}" ]; then
    set -- $dev
    [ -z "${label:-}" ] && [ $# -ge 1 ] && label="$1"
    if [ -z "${ip:-}" ] && [ $# -ge 2 ] && is_ip "$2"; then ip="$2"; fi
    if [ -z "${rule:-}" ] && [ $# -ge 3 ]; then rule="$3"; fi
  fi

  [ -z "${rule:-}" ] && rule="balanced"
  printf 'label=%s ip=%s rule=%s\n' "$label" "$ip" "$rule"
}

ensure_monotonic_ts() {
  tmpf="${1:-}"
  [ -n "${tmpf:-}" ] || return 1
  [ -f "$LAST_SSOT" ] || return 0

  old_ts="$(sed -n "s/.*\"ts\":\([0-9][0-9]*\).*/\1/p" "$LAST_SSOT" 2>/dev/null | head -n 1)"
  new_ts="$(sed -n "s/.*\"ts\":\([0-9][0-9]*\).*/\1/p" "$tmpf" 2>/dev/null | head -n 1)"

  case "${old_ts:-}" in ""|*[!0-9]*) old_ts=0;; esac
  case "${new_ts:-}" in ""|*[!0-9]*) new_ts=$(ts_s);; esac

  if [ "$new_ts" -le "$old_ts" ]; then
    new_ts=$((old_ts + 1))
  fi

  # rewrite ts in JSON (keep contract: integer seconds)
  sed "s/\"ts\":[0-9][0-9]*/\"ts\":${new_ts}/" "$tmpf" >"${tmpf}.t" 2>/dev/null && mv -f "${tmpf}.t" "$tmpf" || true
  return 0
}

run_action() {
  action="$(trim "${1:-}")"
  token="$(trim "${2:-}")"
  profile="$(trim "${3:-}")"
  device="$(trim "${4:-}")"
  payload="$(trim "${5:-}")"

  # --- AUTO TOKEN (backend) ---
  if [ -z "${token:-}" ]; then
    case "$action" in
      status|snapshot|reload|bootstrap|token_get) : ;;
      *)
        tok_tmp="/tmp/avp_webui_tok.$$.$(ts_s)";
        tok_err="${tok_tmp}.err";
        "$ACT" action=token_get >"$tok_tmp" 2>"$tok_err" || true;
        token="$(sed -n 's/.*"token":"\([^"]*\)".*/\1/p' "$tok_tmp" 2>/dev/null | head -n 1)";
        rm -f "$tok_tmp" "$tok_err" 2>/dev/null || true;
        if [ -n "${token:-}" ]; then nvram set avp_webui_token="$token" 2>/dev/null || true; fi
        ;;
    esac
  fi

  # aliases (frontend -> backend)
  case "$action" in
    device_remove) action="device_del" ;;
    device_update) action="device_set" ;;
  esac

  # toggle -> enable/disable (based on POL status enabled)
  if [ "$action" = "toggle" ]; then
    if [ -x "$POL" ]; then
      st="$("$POL" status --json 2>/dev/null | tail -n 1 | tr -d '\r\n')"
      en="$(printf "%s" "$st" | sed -n 's/.*"enabled":\([01]\).*/\1/p' | head -n 1)"
      if [ "$en" = "1" ]; then action="disable"; else action="enable"; fi
    else
      action="enable"
    fi
  fi

  argv="action=$action"
  [ -n "${token:-}" ]   && argv="$argv token=$token"
  [ -n "${profile:-}" ] && argv="$argv profile=$profile"

  case "$action" in
    device_add|device_set)
      kv="$(parse_device_contract "$device" "$payload")"
      label="$(printf "%s" "$kv" | sed -n 's/^label=\([^ ]*\).*/\1/p')"
      ip="$(printf "%s" "$kv" | sed -n 's/.* ip=\([^ ]*\).*/\1/p')"
      rule="$(printf "%s" "$kv" | sed -n 's/.* rule=\([^ ]*\).*/\1/p')"
      [ -n "${label:-}" ] && argv="$argv label=$label"
      [ -n "${ip:-}" ]    && argv="$argv ip=$ip"
      [ -n "${rule:-}" ]  && argv="$argv rule=$rule"
      ;;
    device_del)
      d="$(trim "$device")"
      set -- $d
      [ $# -ge 1 ] && argv="$argv label=$1"
      ;;
  esac

  tmp="/tmp/avp_webui_last.$$.$(ts_s)"
  tmp_err="${tmp}.err"

  if [ ! -x "$ACT" ]; then
    json_err false 10 "dispatch" "avp-action.sh not found" >"$tmp"
    write_last "$tmp"
    log "event=avp_webui_restart action=$action rc=10 msg=avp-action.sh not found"
    rm -f "$tmp" "$tmp_err" 2>/dev/null || true
    return 10
  fi

  "$ACT" $argv >"$tmp" 2>"$tmp_err"
  rc=$?

  first="$(head -n 1 "$tmp" 2>/dev/null || true)"
  case "$first" in
    \{*\}) : ;;
    *)
      emsg="$(tail -n 1 "$tmp_err" 2>/dev/null | head -c 160)"
      [ -z "${emsg:-}" ] && emsg="no-json-from-avp-action"
      json_err false "$rc" "$action" "$emsg" >"$tmp"
      ;;
  esac

  ensure_monotonic_ts "$tmp" || true
  write_last "$tmp" || true
  log "event=avp_webui_restart action=$action rc=$rc argv=[$argv]"
  rm -f "$tmp" "$tmp_err" 2>/dev/null || true
  return "$rc"
}

normalize_call() {
  a1="$(trim "${1:-}")"
  a2="$(trim "${2:-}")"

  verb=""
  tgt=""

  # Merlin default: $1=event (start/stop/restart), $2=target
  case "$a1" in
    start|stop|restart)
      verb="$a1"
      tgt="$a2"
      ;;
    start_*|stop_*|restart_*)
      verb="${a1%%_*}"
      tgt="${a1#*_}"
      ;;
    *)
      # legacy/manual: $1=target only
      verb="manual"
      tgt="$a1"
      ;;
  esac

  printf '%s %s\n' "$verb" "$tgt"
}

main() {
  n="$(normalize_call "$1" "$2")"
  verb="$(printf "%s" "$n" | awk '{print $1}')"
  ev="$(printf "%s" "$n" | awk '{print $2}')"

  log "service-event argv=[$*] verb=$verb target=$ev"

  [ -n "${ev:-}" ] || exit 0

  case "$ev" in
    avp_webui_restart)
      action="$(nvram get avp_webui_action 2>/dev/null || true)"
      token="$(nvram get avp_webui_token 2>/dev/null || true)"
      profile="$(nvram get avp_webui_profile 2>/dev/null || true)"
      device="$(nvram get avp_webui_device 2>/dev/null || true)"
      payload="$(nvram get avp_webui_payload 2>/dev/null || true)"

      action="$(trim "$action")"
      token="$(trim "$token")"
      profile="$(trim "$profile")"
      device="$(trim "$device")"
      payload="$(trim "$payload")"

      [ -n "${action:-}" ] || action="status"
      run_action "$action" "$token" "$profile" "$device" "$payload"
      exit $?
      ;;
    *)
      exit 0
      ;;
  esac
}

main "$@"

exit 0
